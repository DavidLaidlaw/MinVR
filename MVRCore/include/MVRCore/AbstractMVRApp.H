//========================================================================
// MinVR
// Platform:    Any
// API version: 1.0
//------------------------------------------------------------------------
// The MIT License (MIT)
//
// Copyright (c) 2013 Regents of the University of Minnesota
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//========================================================================

#ifndef ABSTRACTMVRAPP_H
#define ABSTRACTMVRAPP_H

#include <G3DLite/G3DLite.h>
#include "MVRCore/Event.H"
#include "MVRCore/ConfigVal.H"
#include "MVRCore/AbstractCamera.H"

namespace MinVR {

typedef G3DLite::ReferenceCountedPointer<class AbstractMVRApp> AbstractMVRAppRef;

/*! @brief Pure virtual base class for MinVR applications.
 *
 */
class AbstractMVRApp : public G3DLite::ReferenceCountedObject
{
public:

	AbstractMVRApp() {}
	virtual ~AbstractMVRApp() {}

	/*! @brief Handle events and computation
	 * 
	 *  This will be called once per frame.  You should do all your program's logic (handling input events,
	 *  doing any required simulation, and so on) within this function.  If you are doing any simulation or
	 *  animation where virtual objects change over time, it is useful to base this code on the time value
	 *  passed in via the synchronizedTime parameter, which is guaranteed to be synchronized across all
	 *  processes when MinVR is run in a clustered rendering environment.
	 *
	 *  @param[in] An array of events generated by devices, mice, and keyboards
	 *  @param[in] The time that has passed since the application launched in ms.
	 */
	virtual void doUserInputAndPreDrawComputation(const G3DLite::Array<EventRef> &events, double synchronizedTime) = 0;

	/*! @brief Initialize OpenGL variables.
	*
	*  This will be called once by each rendering thread as it is created. You should initialize all context
	*  specific variables here such as textures, frame buffer objects, vertex buffer objects, shaders, etc.
	*  Variables can be stored in an array and matched to the specific thread by the threadId, or alternatively,
	*  wrapped as a boost::thread_specific_ptr<> object to automatically create thread specific versions.
	*
	*  @param[in] A unique thread specific id. Ids will start at zero so that they can be used as indices in an array.
	*
	*  @note Initalizing opengl variables elsewhere in the application is not threadsafe!
	*/
	virtual void initializeContextSpecificVars(int threadId) = 0;

	/*! @brief Drawing code.
	 *  This is where all your OpenGL drawing code should go.  This routine is typically called more than
	 *  once per frame.  In a desktop VR environment, this would be called once to draw the image for the
	 *  left eye and then a second time to draw the image for the right eye.  In a 4-wall CAVE where the
	 *  a single graphics window is stretched across all the projection screens and divided into 4 different
	 *  OpenGL viewports, one per wall, this routine would be called 8 times per frame (once per eye for 
	 *  each of the walls).  Before calling this routine, MVREngine will appropriately clear the OpenGL draw
	 *  buffer(s), set the OpenGL projection matrices including applying head tracking data if applicable, 
	 *  use the OpenGL viewport command to specify the correct protion of the screen to draw if applicable, 
	 *  and/or set the stencil buffer properly to draw to stereo displays that require a left/right eye 
	 *  interlaced signal if applicable.  MVREngine determines all of those settings based upon the 
	 *  config variables passed to it at runtime that describe your VR environment.  Since all that is
	 *  handled inside MinVR, the only thing that you should implement in this function is the OpenGL
	 *  code needed to draw your scene. 
	 *
	 *  @param[in] A unique id for the current calling renderthread
	 *  @param[in] A reference to the camera, which can be used to set the current object to world transform.
	 *
	 *  @note This method is called from multiple render threads. Do not modify variables in this method, as it is not thread-safe.
	 */
	virtual void drawGraphics(int threadId, AbstractCameraRef camera) = 0;

};



} // end namespace

#endif


