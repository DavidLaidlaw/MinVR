<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>MinVR: G3DLite::Array&lt; T, MIN_ELEMENTS, MIN_BYTES &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MinVR
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A multi-platform virtual reality library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceG3DLite.html">G3DLite</a></li><li class="navelem"><a class="el" href="classG3DLite_1_1Array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classG3DLite_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">G3DLite::Array&lt; T, MIN_ELEMENTS, MIN_BYTES &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dynamic 1D array tuned for performance.  
 <a href="classG3DLite_1_1Array.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array_1_1DefaultComparator.html">DefaultComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab8c72a767bf45ff47b26e73b67d470fb"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a></td></tr>
<tr class="separator:ab8c72a767bf45ff47b26e73b67d470fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093040bb5a2beb9b83e3ef10f89b08be"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a></td></tr>
<tr class="separator:a093040bb5a2beb9b83e3ef10f89b08be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4aef138b769b0f63ab7db7ccce9b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a87c4aef138b769b0f63ab7db7ccce9b7">iterator</a></td></tr>
<tr class="separator:a87c4aef138b769b0f63ab7db7ccce9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9b9409602e21efa800d6039388b38d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a8d9b9409602e21efa800d6039388b38d">const_iterator</a></td></tr>
<tr class="separator:a8d9b9409602e21efa800d6039388b38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae3fd1b2f609abeb738465ad50a7dc5"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a3ae3fd1b2f609abeb738465ad50a7dc5">value_type</a></td></tr>
<tr class="separator:a3ae3fd1b2f609abeb738465ad50a7dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213c2e718987c3ec31bbc3d0b2166832"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a213c2e718987c3ec31bbc3d0b2166832">size_type</a></td></tr>
<tr class="separator:a213c2e718987c3ec31bbc3d0b2166832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2afa78f099e5f98ba8fafa5f2257d5b"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ae2afa78f099e5f98ba8fafa5f2257d5b">difference_type</a></td></tr>
<tr class="separator:ae2afa78f099e5f98ba8fafa5f2257d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72a933cfe5cd2008c6971bce36f381e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a72a933cfe5cd2008c6971bce36f381e4">begin</a> ()</td></tr>
<tr class="separator:a72a933cfe5cd2008c6971bce36f381e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05096a4bb1ce50788fb80dbcd9ef115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af05096a4bb1ce50788fb80dbcd9ef115">begin</a> () const </td></tr>
<tr class="separator:af05096a4bb1ce50788fb80dbcd9ef115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72dc3eaaa9ddc58d822a4420308fa26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ad72dc3eaaa9ddc58d822a4420308fa26">end</a> () const </td></tr>
<tr class="separator:ad72dc3eaaa9ddc58d822a4420308fa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11ec8bb3de9e639c8597dd1c7d7f0e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af11ec8bb3de9e639c8597dd1c7d7f0e2">end</a> ()</td></tr>
<tr class="separator:af11ec8bb3de9e639c8597dd1c7d7f0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b5adc172a6fe20e3e0f2c3fc84fee1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ac2b5adc172a6fe20e3e0f2c3fc84fee1">getCArray</a> ()</td></tr>
<tr class="separator:ac2b5adc172a6fe20e3e0f2c3fc84fee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff49746eb4bdee5b177ff3589f789380"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#aff49746eb4bdee5b177ff3589f789380">getCArray</a> () const </td></tr>
<tr class="separator:aff49746eb4bdee5b177ff3589f789380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc5ab795567f02cc9f1304cdac2270d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#affc5ab795567f02cc9f1304cdac2270d">Array</a> ()</td></tr>
<tr class="separator:affc5ab795567f02cc9f1304cdac2270d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae170cc8362afc12d5d7ca55f94653e3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ae170cc8362afc12d5d7ca55f94653e3c">Array</a> (const T &amp;v0)</td></tr>
<tr class="separator:ae170cc8362afc12d5d7ca55f94653e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c41a78a288b6d4481b60adc257c4a03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a8c41a78a288b6d4481b60adc257c4a03">Array</a> (const T &amp;v0, const T &amp;v1)</td></tr>
<tr class="separator:a8c41a78a288b6d4481b60adc257c4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e476e9680d9011c7eabc7a902b65ba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a8e476e9680d9011c7eabc7a902b65ba8">Array</a> (const T &amp;v0, const T &amp;v1, const T &amp;v2)</td></tr>
<tr class="separator:a8e476e9680d9011c7eabc7a902b65ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f76c105699701965d37e6654753aed7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a4f76c105699701965d37e6654753aed7">Array</a> (const T &amp;v0, const T &amp;v1, const T &amp;v2, const T &amp;v3)</td></tr>
<tr class="separator:a4f76c105699701965d37e6654753aed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac158d1181dcf05ca465d5874e18528"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a9ac158d1181dcf05ca465d5874e18528">Array</a> (const T &amp;v0, const T &amp;v1, const T &amp;v2, const T &amp;v3, const T &amp;v4)</td></tr>
<tr class="separator:a9ac158d1181dcf05ca465d5874e18528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ff32503924074059d9e4cc9ec5f323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af5ff32503924074059d9e4cc9ec5f323">Array</a> (const <a class="el" href="classG3DLite_1_1Array.html">Array</a> &amp;other)</td></tr>
<tr class="separator:af5ff32503924074059d9e4cc9ec5f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616a87291f57d0063702e4074ee8ee6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a616a87291f57d0063702e4074ee8ee6b">~Array</a> ()</td></tr>
<tr class="separator:a616a87291f57d0063702e4074ee8ee6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2797d84d46ff86d7c7c14e2975820a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a2797d84d46ff86d7c7c14e2975820a4e">clear</a> (bool shrink=true)</td></tr>
<tr class="separator:a2797d84d46ff86d7c7c14e2975820a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e175597315b66610553be5c94ae3b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a6e175597315b66610553be5c94ae3b19">clearAndSetMemoryManager</a> (const <a class="el" href="classG3DLite_1_1MemoryManager.html#a648b65a454b54c9ee2b6085f98966acc">MemoryManager::Ref</a> &amp;m)</td></tr>
<tr class="separator:a6e175597315b66610553be5c94ae3b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9076458d46f00587504b0ce471d12f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a9076458d46f00587504b0ce471d12f93">fastClear</a> ()</td></tr>
<tr class="separator:a9076458d46f00587504b0ce471d12f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e88676c8498f541ddf8377a68e64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ae47e88676c8498f541ddf8377a68e64e">operator=</a> (const <a class="el" href="classG3DLite_1_1Array.html">Array</a> &amp;other)</td></tr>
<tr class="separator:ae47e88676c8498f541ddf8377a68e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9f2140ffccc5b6b5c73d10ff6318a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#afd9f2140ffccc5b6b5c73d10ff6318a5">operator=</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:afd9f2140ffccc5b6b5c73d10ff6318a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc5fc6e2a15a98c03dd6b4af3f50b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1MemoryManager.html#a648b65a454b54c9ee2b6085f98966acc">MemoryManager::Ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a0fc5fc6e2a15a98c03dd6b4af3f50b52">memoryManager</a> () const </td></tr>
<tr class="separator:a0fc5fc6e2a15a98c03dd6b4af3f50b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95c3361deedf880060fbb172f3dc8bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#aa95c3361deedf880060fbb172f3dc8bd">size</a> () const </td></tr>
<tr class="separator:aa95c3361deedf880060fbb172f3dc8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07847d2e25072a03000eda1a5c703ddf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a07847d2e25072a03000eda1a5c703ddf">length</a> () const </td></tr>
<tr class="separator:a07847d2e25072a03000eda1a5c703ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b1225eb33a81527cce47bcbf945872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af4b1225eb33a81527cce47bcbf945872">fastRemove</a> (int index, bool shrinkIfNecessary=false)</td></tr>
<tr class="separator:af4b1225eb33a81527cce47bcbf945872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c3e6696ad2e9d1ea42d2c8dbdb832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a373c3e6696ad2e9d1ea42d2c8dbdb832">insert</a> (int n, const T &amp;value)</td></tr>
<tr class="separator:a373c3e6696ad2e9d1ea42d2c8dbdb832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a56b6b4d0dfd993954e554a0b1ed7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a473a56b6b4d0dfd993954e554a0b1ed7">resize</a> (int n, bool shrinkIfNecessary=true)</td></tr>
<tr class="separator:a473a56b6b4d0dfd993954e554a0b1ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2d3e074e04d3e8680d4333debf1359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a4d2d3e074e04d3e8680d4333debf1359">append</a> (const T &amp;value)</td></tr>
<tr class="separator:a4d2d3e074e04d3e8680d4333debf1359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b60e3ff1c6c59ca543cc9ee2e96fda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a9b60e3ff1c6c59ca543cc9ee2e96fda4">append</a> (const T &amp;v1, const T &amp;v2)</td></tr>
<tr class="separator:a9b60e3ff1c6c59ca543cc9ee2e96fda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ed293a8d74bb31a3fa823b50fd9f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ab5ed293a8d74bb31a3fa823b50fd9f88">append</a> (const T &amp;v1, const T &amp;v2, const T &amp;v3)</td></tr>
<tr class="separator:ab5ed293a8d74bb31a3fa823b50fd9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41734f4db5a8dc0620d3040ced11a81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a41734f4db5a8dc0620d3040ced11a81e">append</a> (const T &amp;v1, const T &amp;v2, const T &amp;v3, const T &amp;v4)</td></tr>
<tr class="separator:a41734f4db5a8dc0620d3040ced11a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23971e8447a98d765e42cb5130183a56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a23971e8447a98d765e42cb5130183a56">contains</a> (const T &amp;e) const </td></tr>
<tr class="separator:a23971e8447a98d765e42cb5130183a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d6b840e3699b02d0b71f74dbbbd4ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a61d6b840e3699b02d0b71f74dbbbd4ed">append</a> (const <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a61d6b840e3699b02d0b71f74dbbbd4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d68f763c630e795f6eec2b072ad484f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a4d68f763c630e795f6eec2b072ad484f">next</a> ()</td></tr>
<tr class="separator:a4d68f763c630e795f6eec2b072ad484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9885fedbee979e045bee2c7195ce2967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a9885fedbee979e045bee2c7195ce2967">push</a> (const T &amp;value)</td></tr>
<tr class="separator:a9885fedbee979e045bee2c7195ce2967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f784387b4016e9f865e5712ab5e984b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a3f784387b4016e9f865e5712ab5e984b">push</a> (const <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a3f784387b4016e9f865e5712ab5e984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7a087c59af55f00c59c79f360a09b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a5d7a087c59af55f00c59c79f360a09b4">push_back</a> (const T &amp;v)</td></tr>
<tr class="separator:a5d7a087c59af55f00c59c79f360a09b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad889a50b2572069ff92729469a2455d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ad889a50b2572069ff92729469a2455d2">pop_back</a> ()</td></tr>
<tr class="separator:ad889a50b2572069ff92729469a2455d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f8f326b822e775eb9c750b0ae5433"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#afa1f8f326b822e775eb9c750b0ae5433">capacity</a> () const </td></tr>
<tr class="separator:afa1f8f326b822e775eb9c750b0ae5433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db4f6acd81c31c435c976a08b81a34c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a6db4f6acd81c31c435c976a08b81a34c">front</a> ()</td></tr>
<tr class="separator:a6db4f6acd81c31c435c976a08b81a34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5203f283d3d2b41897371f550b23aa94"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a5203f283d3d2b41897371f550b23aa94">front</a> () const </td></tr>
<tr class="separator:a5203f283d3d2b41897371f550b23aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1131d09f4c62ba1f5448a066baf0ee"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#abb1131d09f4c62ba1f5448a066baf0ee">back</a> ()</td></tr>
<tr class="separator:abb1131d09f4c62ba1f5448a066baf0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e4891180750449a83312fd73ab702"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a544e4891180750449a83312fd73ab702">back</a> () const </td></tr>
<tr class="separator:a544e4891180750449a83312fd73ab702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d84bc15b3b680cce0633d2805ca2632"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a1d84bc15b3b680cce0633d2805ca2632">pop</a> (bool shrinkUnderlyingArrayIfNecessary=true)</td></tr>
<tr class="separator:a1d84bc15b3b680cce0633d2805ca2632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18773f034492bae36f1ac901e0ecee02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a18773f034492bae36f1ac901e0ecee02">popDiscard</a> (bool shrinkUnderlyingArrayIfNecessary=false)</td></tr>
<tr class="separator:a18773f034492bae36f1ac901e0ecee02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ced3a30c62f7dbc7115a590ab2336ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a0ced3a30c62f7dbc7115a590ab2336ec">swap</a> (<a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a0ced3a30c62f7dbc7115a590ab2336ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01709fc6be34c40998828fe19af45f49"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a01709fc6be34c40998828fe19af45f49">operator[]</a> (int n)</td></tr>
<tr class="separator:a01709fc6be34c40998828fe19af45f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bac408130161b5e4c3ff012de0caa8a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a0bac408130161b5e4c3ff012de0caa8a">operator[]</a> (unsigned int n)</td></tr>
<tr class="separator:a0bac408130161b5e4c3ff012de0caa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0315b3b1df3838b81a98a2ebb4943242"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a0315b3b1df3838b81a98a2ebb4943242">operator[]</a> (int n) const </td></tr>
<tr class="separator:a0315b3b1df3838b81a98a2ebb4943242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22b36a39d87456ebf6c3f4b91db48e9"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ad22b36a39d87456ebf6c3f4b91db48e9">operator[]</a> (unsigned int n) const </td></tr>
<tr class="separator:ad22b36a39d87456ebf6c3f4b91db48e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575bc2b331faa2dfb64604f8d5f5d6bd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a575bc2b331faa2dfb64604f8d5f5d6bd">randomElement</a> ()</td></tr>
<tr class="separator:a575bc2b331faa2dfb64604f8d5f5d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffc5ffc4b69f9c2038a236be9751e40"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a3ffc5ffc4b69f9c2038a236be9751e40">randomElement</a> () const </td></tr>
<tr class="separator:a3ffc5ffc4b69f9c2038a236be9751e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5546eb558dc5bb429dc8a88175170c9e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a5546eb558dc5bb429dc8a88175170c9e">last</a> () const </td></tr>
<tr class="separator:a5546eb558dc5bb429dc8a88175170c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cce7b42c31d079ce94bcf48602d8d6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a56cce7b42c31d079ce94bcf48602d8d6">last</a> ()</td></tr>
<tr class="separator:a56cce7b42c31d079ce94bcf48602d8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c70ba96f7ef48505093dcf5ce5555a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af6c70ba96f7ef48505093dcf5ce5555a">lastIndex</a> () const </td></tr>
<tr class="separator:af6c70ba96f7ef48505093dcf5ce5555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619235ac68890fe2579c8b8cb0da798a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a619235ac68890fe2579c8b8cb0da798a">firstIndex</a> () const </td></tr>
<tr class="separator:a619235ac68890fe2579c8b8cb0da798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64576b754ed3adb1906b85c21756f1bf"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a64576b754ed3adb1906b85c21756f1bf">first</a> ()</td></tr>
<tr class="separator:a64576b754ed3adb1906b85c21756f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba13de279cb7db351406afb50b7ae0"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a0cba13de279cb7db351406afb50b7ae0">first</a> () const </td></tr>
<tr class="separator:a0cba13de279cb7db351406afb50b7ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04da8b65634438e4903c6f304bbdf89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af04da8b65634438e4903c6f304bbdf89">middleIndex</a> () const </td></tr>
<tr class="separator:af04da8b65634438e4903c6f304bbdf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fa781c0ebc20e23ceda979b52e2d58"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a56fa781c0ebc20e23ceda979b52e2d58">middle</a> () const </td></tr>
<tr class="separator:a56fa781c0ebc20e23ceda979b52e2d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a551afefb7f03efda956d2e595da42"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a34a551afefb7f03efda956d2e595da42">middle</a> ()</td></tr>
<tr class="separator:a34a551afefb7f03efda956d2e595da42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef46738f1ba3f42ca567a3db42e7c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a9ef46738f1ba3f42ca567a3db42e7c40">deleteAll</a> ()</td></tr>
<tr class="separator:a9ef46738f1ba3f42ca567a3db42e7c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150dbdce86dc9d77ed557637080f25d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a150dbdce86dc9d77ed557637080f25d4">rfindIndex</a> (const T &amp;value) const </td></tr>
<tr class="separator:a150dbdce86dc9d77ed557637080f25d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4722b06f528a249af8148e7cba8ac1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#acf4722b06f528a249af8148e7cba8ac1">findIndex</a> (const T &amp;value) const </td></tr>
<tr class="separator:acf4722b06f528a249af8148e7cba8ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583573aec29f7c159a1883041791b28f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a583573aec29f7c159a1883041791b28f">find</a> (const T &amp;value)</td></tr>
<tr class="separator:a583573aec29f7c159a1883041791b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c302f00fbcd0cd0f869101d94ba1f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a1c302f00fbcd0cd0f869101d94ba1f8f">find</a> (const T &amp;value) const </td></tr>
<tr class="separator:a1c302f00fbcd0cd0f869101d94ba1f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e20229ffde1d23633b84fa28c3fc12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a15e20229ffde1d23633b84fa28c3fc12">remove</a> (<a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a> element, int count=1)</td></tr>
<tr class="separator:a15e20229ffde1d23633b84fa28c3fc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d35d3b46cc195094c04c56be2adc577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a0d35d3b46cc195094c04c56be2adc577">remove</a> (int index, int count=1)</td></tr>
<tr class="separator:a0d35d3b46cc195094c04c56be2adc577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af478efea649696b18bc2bdf3f19e85dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#af478efea649696b18bc2bdf3f19e85dd">reverse</a> ()</td></tr>
<tr class="separator:af478efea649696b18bc2bdf3f19e85dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb662283781f38fd1bf9ac8861b8cd96"><td class="memTemplParams" colspan="2">template&lt;class LessThan &gt; </td></tr>
<tr class="memitem:adb662283781f38fd1bf9ac8861b8cd96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#adb662283781f38fd1bf9ac8861b8cd96">sort</a> (const LessThan &amp;lessThan)</td></tr>
<tr class="separator:adb662283781f38fd1bf9ac8861b8cd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf60eb31aef2c6698d3ccfee0f0cfea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#acf60eb31aef2c6698d3ccfee0f0cfea6">sort</a> (int direction=<a class="el" href="namespaceG3DLite.html#ab5f0404afe631bf268987434f6fe65f2">SORT_INCREASING</a>)</td></tr>
<tr class="separator:acf60eb31aef2c6698d3ccfee0f0cfea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac855a4719b07c6f79ea2c01c00346772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ac855a4719b07c6f79ea2c01c00346772">sortSubArray</a> (int beginIndex, int endIndex, int direction=<a class="el" href="namespaceG3DLite.html#ab5f0404afe631bf268987434f6fe65f2">SORT_INCREASING</a>)</td></tr>
<tr class="separator:ac855a4719b07c6f79ea2c01c00346772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dc884c05cd8a91cdf6d04928788b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a47dc884c05cd8a91cdf6d04928788b20">sortSubArray</a> (int beginIndex, int endIndex, bool(__cdecl *lessThan)(const T &amp;elem1, const T &amp;elem2))</td></tr>
<tr class="separator:a47dc884c05cd8a91cdf6d04928788b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d3bc71da0a849967dd528b5ad78c3c"><td class="memTemplParams" colspan="2">template&lt;typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ad0d3bc71da0a849967dd528b5ad78c3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ad0d3bc71da0a849967dd528b5ad78c3c">sortSubArray</a> (int beginIndex, int endIndex, StrictWeakOrdering &amp;lessThan)</td></tr>
<tr class="separator:ad0d3bc71da0a849967dd528b5ad78c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3a56f11268cdf406537a2065166d9"><td class="memTemplParams" colspan="2">template&lt;typename Comparator &gt; </td></tr>
<tr class="memitem:a4dd3a56f11268cdf406537a2065166d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a4dd3a56f11268cdf406537a2065166d9">partition</a> (const T &amp;partitionElement, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;ltArray, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;eqArray, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;gtArray, const Comparator &amp;comparator) const </td></tr>
<tr class="separator:a4dd3a56f11268cdf406537a2065166d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912eed74a3f24496609bc9212933370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#a2912eed74a3f24496609bc9212933370">partition</a> (const T &amp;partitionElement, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;ltArray, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;eqArray, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;gtArray) const </td></tr>
<tr class="separator:a2912eed74a3f24496609bc9212933370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cb1d29e80e7c04eb13ef74b44403a6"><td class="memTemplParams" colspan="2">template&lt;typename Comparator &gt; </td></tr>
<tr class="memitem:ae7cb1d29e80e7c04eb13ef74b44403a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#ae7cb1d29e80e7c04eb13ef74b44403a6">medianPartition</a> (<a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;ltMedian, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;eqMedian, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;gtMedian, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;tempArray, const Comparator &amp;comparator) const </td></tr>
<tr class="separator:ae7cb1d29e80e7c04eb13ef74b44403a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae024bf38916e22b6be470091e0f9955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#aae024bf38916e22b6be470091e0f9955">medianPartition</a> (<a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;ltMedian, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;eqMedian, <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;gtMedian) const </td></tr>
<tr class="separator:aae024bf38916e22b6be470091e0f9955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1753e37e6a55750a9d23acfc59fea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3DLite_1_1Array.html#aaa1753e37e6a55750a9d23acfc59fea9">randomize</a> ()</td></tr>
<tr class="separator:aaa1753e37e6a55750a9d23acfc59fea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt;<br/>
class G3DLite::Array&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;</h3>

<p>Objects must have a default constructor (constructor that takes no arguments) in order to be used with this template. You will get the error "no appropriate default constructor found" if they do not.</p>
<p>Do not use with objects that overload placement <code>operator new</code>, since the speed of <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> is partly due to pooled allocation.</p>
<p><a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> is highly optimized compared to std::vector. <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> operations are less expensive than on std::vector and for large amounts of data, <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> consumes only 1.5x the total size of the data, while std::vector consumes 2.0x. The default array takes up zero heap space. The first resize (or append) operation grows it to a reasonable internal size so it is efficient to append to small arrays.</p>
<p>Then <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> needs to copy data internally on a resize operation it correctly invokes copy constructors of the elements (the MSVC6 implementation of std::vector uses realloc, which can create memory leaks for classes containing references and pointers). <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> provides a guaranteed safe way to access the underlying data as a flat C array &ndash; <a class="el" href="classG3DLite_1_1Array.html#ac2b5adc172a6fe20e3e0f2c3fc84fee1">Array::getCArray</a>. Although (T*)std::vector::begin() can be used for this purpose, it is not guaranteed to succeed on all platforms.</p>
<p>To serialize an array, see <a class="el" href="namespaceG3DLite.html#a983805cbb1e071283db916fa3cbe1900">G3DLite::serialize</a>.</p>
<p>The template parameter MIN_ELEMENTS indicates the smallest number of elements that will be allocated. The default of 10 is designed to avoid the overhead of repeatedly allocating the array as it grows from 1, to 2, and so on. If you are creating a lot of small Arrays, however, you may want to set this smaller to reduce the memory cost. Once the array has been allocated, it will never deallocate the underlying array unless MIN_ELEMENTS is set to 0, MIN_BYTES is 0, and the array is empty.</p>
<p>Do not subclass an <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a>.</p>
<dl class="section see"><dt>See Also</dt><dd>G3DLite::SmallArray </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8d9b9409602e21efa800d6039388b38d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#a8d9b9409602e21efa800d6039388b38d">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stl porting compatibility helper </p>

</div>
</div>
<a class="anchor" id="a093040bb5a2beb9b83e3ef10f89b08be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>G3D C++ STL style const iterator in same style as Iterator. </p>

</div>
</div>
<a class="anchor" id="ae2afa78f099e5f98ba8fafa5f2257d5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#ae2afa78f099e5f98ba8fafa5f2257d5b">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stl porting compatibility helper </p>

</div>
</div>
<a class="anchor" id="ab8c72a767bf45ff47b26e73b67d470fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>G3D C++ STL style iterator variable. Call <a class="el" href="classG3DLite_1_1Array.html#a72a933cfe5cd2008c6971bce36f381e4">begin()</a> to get the first iterator, pre-increment (++i) the iterator to get to the next value. Use dereference (*i) to access the element. </p>

</div>
</div>
<a class="anchor" id="a87c4aef138b769b0f63ab7db7ccce9b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#a87c4aef138b769b0f63ab7db7ccce9b7">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stl porting compatibility helper </p>

</div>
</div>
<a class="anchor" id="a213c2e718987c3ec31bbc3d0b2166832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#a213c2e718987c3ec31bbc3d0b2166832">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stl porting compatibility helper </p>

</div>
</div>
<a class="anchor" id="a3ae3fd1b2f609abeb738465ad50a7dc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html#a3ae3fd1b2f609abeb738465ad50a7dc5">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stl porting compatibility helper </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="affc5ab795567f02cc9f1304cdac2270d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a zero length array (no heap allocation occurs until resize). </p>

</div>
</div>
<a class="anchor" id="ae170cc8362afc12d5d7ca55f94653e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v0</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an array containing v0. </p>

</div>
</div>
<a class="anchor" id="a8c41a78a288b6d4481b60adc257c4a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an array containing v0 and v1. </p>

</div>
</div>
<a class="anchor" id="a8e476e9680d9011c7eabc7a902b65ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an array containing v0...v2. </p>

</div>
</div>
<a class="anchor" id="a4f76c105699701965d37e6654753aed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an array containing v0...v3. </p>

</div>
</div>
<a class="anchor" id="a9ac158d1181dcf05ca465d5874e18528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an array containing v0...v4. </p>

</div>
</div>
<a class="anchor" id="af5ff32503924074059d9e4cc9ec5f323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p>

</div>
</div>
<a class="anchor" id="a616a87291f57d0063702e4074ee8ee6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::~<a class="el" href="classG3DLite_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor does not delete() the objects if T is a pointer type (e.g. T = int*) instead, it deletes the <b>pointers themselves</b> and leaves the objects. Call deleteAll if you want to dealocate the objects referenced. Do not call deleteAll if <code>T</code> is not a pointer type (e.g. do call <a class="el" href="classG3DLite_1_1Array.html#a9ef46738f1ba3f42ca567a3db42e7c40">Array&lt;Foo*&gt;::deleteAll</a>, do <b>not</b> call <a class="el" href="classG3DLite_1_1Array.html#a9ef46738f1ba3f42ca567a3db42e7c40">Array&lt;Foo&gt;::deleteAll</a>). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4d2d3e074e04d3e8680d4333debf1359"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an element to the end of the array. Will not shrink the underlying array under any circumstances. It is safe to append an element that is already in the array. </p>

</div>
</div>
<a class="anchor" id="a9b60e3ff1c6c59ca543cc9ee2e96fda4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5ed293a8d74bb31a3fa823b50fd9f88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41734f4db5a8dc0620d3040ced11a81e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a61d6b840e3699b02d0b71f74dbbbd4ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append the elements of array. Cannot be called with this array as an argument. </p>

</div>
</div>
<a class="anchor" id="abb1131d09f4c62ba1f5448a066baf0ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::back </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function returns a reference to the last element of the controlled sequence, 
 which must be non-empty." For compatibility with std::vector. </p>

</div>
</div>
<a class="anchor" id="a544e4891180750449a83312fd73ab702"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::back </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function returns a reference to the last element of the controlled sequence, 
 which must be non-empty." For compatibility with std::vector. </p>

</div>
</div>
<a class="anchor" id="a72a933cfe5cd2008c6971bce36f381e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::begin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++ STL style iterator method. Returns the first iterator element. Do not change the size of the array while iterating. </p>

</div>
</div>
<a class="anchor" id="af05096a4bb1ce50788fb80dbcd9ef115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::begin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa1f8f326b822e775eb9c750b0ae5433"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::capacity </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function returns the storage currently allocated to hold the controlled
 sequence, a value at least as large as size()" For compatibility with std::vector. </p>

</div>
</div>
<a class="anchor" id="a2797d84d46ff86d7c7c14e2975820a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrink</em> = <code>true</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements. Use resize(0, false) or fastClear if you want to remove all elements without deallocating the underlying array so that future <a class="el" href="classG3DLite_1_1Array.html#a4d2d3e074e04d3e8680d4333debf1359">append()</a> calls will be faster. </p>

</div>
</div>
<a class="anchor" id="a6e175597315b66610553be5c94ae3b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::clearAndSetMemoryManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3DLite_1_1MemoryManager.html#a648b65a454b54c9ee2b6085f98966acc">MemoryManager::Ref</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23971e8447a98d765e42cb5130183a56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given element is in the array. </p>

</div>
</div>
<a class="anchor" id="a9ef46738f1ba3f42ca567a3db42e7c40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::deleteAll </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls delete on all objects[0...size-1] and sets the size to zero. </p>

</div>
</div>
<a class="anchor" id="ad72dc3eaaa9ddc58d822a4420308fa26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::end </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++ STL style iterator method. Returns one after the last iterator element. </p>

</div>
</div>
<a class="anchor" id="af11ec8bb3de9e639c8597dd1c7d7f0e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::end </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9076458d46f00587504b0ce471d12f93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::fastClear </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>resize(0, false) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af4b1225eb33a81527cce47bcbf945872"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::fastRemove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrinkIfNecessary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps element index with the last element in the array then shrinks the array by one. </p>

</div>
</div>
<a class="anchor" id="a583573aec29f7c159a1883041791b28f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element and returns the iterator to it. If the element isn't found then returns <a class="el" href="classG3DLite_1_1Array.html#af11ec8bb3de9e639c8597dd1c7d7f0e2">end()</a>. </p>

</div>
</div>
<a class="anchor" id="a1c302f00fbcd0cd0f869101d94ba1f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html#a093040bb5a2beb9b83e3ef10f89b08be">ConstIterator</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf4722b06f528a249af8148e7cba8ac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::findIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index of (the first occurance of) an index or -1 if not found. </p>

</div>
</div>
<a class="anchor" id="a64576b754ed3adb1906b85c21756f1bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::first </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns element <a class="el" href="classG3DLite_1_1Array.html#a619235ac68890fe2579c8b8cb0da798a">firstIndex()</a>, performing a check in debug mode to ensure that there is at least one </p>

</div>
</div>
<a class="anchor" id="a0cba13de279cb7db351406afb50b7ae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::first </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a619235ac68890fe2579c8b8cb0da798a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::firstIndex </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6db4f6acd81c31c435c976a08b81a34c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::front </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function returns a reference to the first element of the controlled sequence, 
 which must be non-empty." For compatibility with std::vector. </p>

</div>
</div>
<a class="anchor" id="a5203f283d3d2b41897371f550b23aa94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::front </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function returns a reference to the first element of the controlled sequence, 
 which must be non-empty." For compatibility with std::vector. </p>

</div>
</div>
<a class="anchor" id="ac2b5adc172a6fe20e3e0f2c3fc84fee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::getCArray </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array returned is only valid until the next <a class="el" href="classG3DLite_1_1Array.html#a4d2d3e074e04d3e8680d4333debf1359">append()</a> or resize call, or the <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> is deallocated. </p>

</div>
</div>
<a class="anchor" id="aff49746eb4bdee5b177ff3589f789380"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::getCArray </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array returned is only valid until the next <a class="el" href="classG3DLite_1_1Array.html#a4d2d3e074e04d3e8680d4333debf1359">append()</a> or resize call, or the <a class="el" href="classG3DLite_1_1Array.html" title="Dynamic 1D array tuned for performance. ">Array</a> is deallocated. </p>

</div>
</div>
<a class="anchor" id="a373c3e6696ad2e9d1ea42d2c8dbdb832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts at the specified index and shifts all other elements up by one. </p>

</div>
</div>
<a class="anchor" id="a5546eb558dc5bb429dc8a88175170c9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::last </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the last element, performing a check in debug mode that there is at least one element. </p>

</div>
</div>
<a class="anchor" id="a56cce7b42c31d079ce94bcf48602d8d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::last </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns element <a class="el" href="classG3DLite_1_1Array.html#af6c70ba96f7ef48505093dcf5ce5555a">lastIndex()</a> </p>

</div>
</div>
<a class="anchor" id="af6c70ba96f7ef48505093dcf5ce5555a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::lastIndex </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <em><a class="el" href="classG3DLite_1_1Array.html#aa95c3361deedf880060fbb172f3dc8bd">size()</a> - 1</em> </p>

</div>
</div>
<a class="anchor" id="a07847d2e25072a03000eda1a5c703ddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::length </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of elements in the array. (Same as size; this is just here for convenience). </p>

</div>
</div>
<a class="anchor" id="ae7cb1d29e80e7c04eb13ef74b44403a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<div class="memtemplate">
template&lt;typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::medianPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ltMedian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eqMedian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gtMedian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tempArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Paritions the array into those below the median, those above the median, and those elements equal to the median in expected O(n) time using quickselect. If the array has an even number of different elements, the median for partition purposes is the largest value less than the median.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tempArray</td><td>used for working scratch space </td></tr>
    <tr><td class="paramname">comparator</td><td>see parition() for a discussion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae024bf38916e22b6be470091e0f9955"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::medianPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ltMedian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eqMedian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gtMedian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a median partition using the default comparator and a dynamically allocated temporary working array. If the median is not in the array, it is chosen to be the largest value smaller than the true median. </p>

</div>
</div>
<a class="anchor" id="a0fc5fc6e2a15a98c03dd6b4af3f50b52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1MemoryManager.html#a648b65a454b54c9ee2b6085f98966acc">MemoryManager::Ref</a> <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::memoryManager </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a56fa781c0ebc20e23ceda979b52e2d58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::middle </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns element <a class="el" href="classG3DLite_1_1Array.html#af04da8b65634438e4903c6f304bbdf89">middleIndex()</a> </p>

</div>
</div>
<a class="anchor" id="a34a551afefb7f03efda956d2e595da42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::middle </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns element <a class="el" href="classG3DLite_1_1Array.html#af04da8b65634438e4903c6f304bbdf89">middleIndex()</a> </p>

</div>
</div>
<a class="anchor" id="af04da8b65634438e4903c6f304bbdf89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::middleIndex </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns iFloor(<a class="el" href="classG3DLite_1_1Array.html#aa95c3361deedf880060fbb172f3dc8bd">size()</a> / 2), throws an assertion in debug mode if the array is empty </p>

</div>
</div>
<a class="anchor" id="a4d68f763c630e795f6eec2b072ad484f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::next </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pushes a new element onto the end and returns its address. This is the same as A.resize(A.size() + 1, false); A.last() </p>

</div>
</div>
<a class="anchor" id="ae47e88676c8498f541ddf8377a68e64e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. </p>

</div>
</div>
<a class="anchor" id="afd9f2140ffccc5b6b5c73d10ff6318a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01709fc6be34c40998828fe19af45f49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs bounds checks in debug mode </p>

</div>
</div>
<a class="anchor" id="a0bac408130161b5e4c3ff012de0caa8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0315b3b1df3838b81a98a2ebb4943242"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs bounds checks in debug mode </p>

</div>
</div>
<a class="anchor" id="ad22b36a39d87456ebf6c3f4b91db48e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dd3a56f11268cdf406537a2065166d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<div class="memtemplate">
template&lt;typename Comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>partitionElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ltArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eqArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gtArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The output arrays are resized with <a class="el" href="classG3DLite_1_1Array.html#a9076458d46f00587504b0ce471d12f93">fastClear()</a> so that if they are already of the same size as this array no memory is allocated during partitioning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>A function, or class instance with an overloaded operator() that compares two elements of type <code>T</code> and returns 0 if they are equal, -1 if the second is smaller, and 1 if the first is smaller (i.e., following the conventions of std::string::compare). For example:</td></tr>
  </table>
  </dd>
</dl>
<pre>
int compare(int A, int B) {
    if (A &lt; B) {
        return 1;
    } else if (A == B) {
        return 0;
    } else {
        return -1;
    }
}
</pre> 
</div>
</div>
<a class="anchor" id="a2912eed74a3f24496609bc9212933370"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>partitionElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ltArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eqArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gtArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses &lt; and == on elements to perform a partition. See <a class="el" href="classG3DLite_1_1Array.html#a4dd3a56f11268cdf406537a2065166d9">partition()</a>. </p>

</div>
</div>
<a class="anchor" id="a1d84bc15b3b680cce0633d2805ca2632"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrinkUnderlyingArrayIfNecessary</em> = <code>true</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the last element and returns it. By default, shrinks the underlying array. </p>

</div>
</div>
<a class="anchor" id="ad889a50b2572069ff92729469a2455d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function removes the last element of the controlled sequence, which must be non-empty." For compatibility with std::vector. </p>

</div>
</div>
<a class="anchor" id="a18773f034492bae36f1ac901e0ecee02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::popDiscard </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrinkUnderlyingArrayIfNecessary</em> = <code>false</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pops the last element and discards it without returning anything. Faster than pop. By default, does not shrink the underlying array. </p>

</div>
</div>
<a class="anchor" id="a9885fedbee979e045bee2c7195ce2967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pushes an element onto the end (appends) </p>

</div>
</div>
<a class="anchor" id="a3f784387b4016e9f865e5712ab5e984b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d7a087c59af55f00c59c79f360a09b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias to provide std::vector compatibility </p>

</div>
</div>
<a class="anchor" id="a575bc2b331faa2dfb64604f8d5f5d6bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::randomElement </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ffc5ffc4b69f9c2038a236be9751e40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::randomElement </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa1753e37e6a55750a9d23acfc59fea9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::randomize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Redistributes the elements so that the new order is statistically independent of the original order. O(n) time. </p>

</div>
</div>
<a class="anchor" id="a15e20229ffde1d23633b84fa28c3fc12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html#ab8c72a767bf45ff47b26e73b67d470fb">Iterator</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes count elements from the array referenced either by index or Iterator. </p>

</div>
</div>
<a class="anchor" id="a0d35d3b46cc195094c04c56be2adc577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a473a56b6b4d0dfd993954e554a0b1ed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrinkIfNecessary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shrinkIfNecessary</td><td>if false, memory will never be reallocated when the array shrinks. This makes resizing much faster but can waste memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af478efea649696b18bc2bdf3f19e85dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::reverse </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reverse the elements of the array in place. </p>

</div>
</div>
<a class="anchor" id="a150dbdce86dc9d77ed557637080f25d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::rfindIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index of (the first occurance of) an index or -1 if not found. Searches from the right. </p>

</div>
</div>
<a class="anchor" id="aa95c3361deedf880060fbb172f3dc8bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::size </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of elements in the array. </p>

</div>
</div>
<a class="anchor" id="adb662283781f38fd1bf9ac8861b8cd96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<div class="memtemplate">
template&lt;class LessThan &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">const LessThan &amp;&#160;</td>
          <td class="paramname"><em>lessThan</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Sort using a specific less-than function, e.g.:
</pre><pre>
    bool __cdecl myLT(const MyClass&amp; elem1, const MyClass&amp; elem2) {
        return elem1.x &lt; elem2.x;
    }
    </pre><p>Note that for pointer arrays, the <code>const</code> must come <em>after</em> the class name, e.g., <code>Array&lt;MyClass*&gt;</code> uses:</p>
<pre>
    bool __cdecl myLT(MyClass*const&amp; elem1, MyClass*const&amp; elem2) {
        return elem1-&gt;x &lt; elem2-&gt;x;
    }
    </pre><p>or a functor, e.g., </p>
<pre>
bool
less_than_functor::operator()( const double&amp; lhs, const double&amp; rhs ) const
{
return( lhs &lt; rhs? true : false );
}
</pre> 
</div>
</div>
<a class="anchor" id="acf60eb31aef2c6698d3ccfee0f0cfea6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="namespaceG3DLite.html#ab5f0404afe631bf268987434f6fe65f2">SORT_INCREASING</a></code>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the array in increasing order using the &gt; or &lt; operator. To invoke this method on Array&lt;T&gt;, T must override those operator. You can overide these operators as follows: <code> bool T::operator&gt;(const T&amp; other) const { return ...; } bool T::operator&lt;(const T&amp; other) const { return ...; } </code> </p>

</div>
</div>
<a class="anchor" id="ac855a4719b07c6f79ea2c01c00346772"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::sortSubArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="namespaceG3DLite.html#ab5f0404afe631bf268987434f6fe65f2">SORT_INCREASING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts elements beginIndex through and including endIndex. </p>

</div>
</div>
<a class="anchor" id="a47dc884c05cd8a91cdf6d04928788b20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::sortSubArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(__cdecl *lessThan)(const T &amp;elem1, const T &amp;elem2)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0d3bc71da0a849967dd528b5ad78c3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<div class="memtemplate">
template&lt;typename StrictWeakOrdering &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::sortSubArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering &amp;&#160;</td>
          <td class="paramname"><em>lessThan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The StrictWeakOrdering can be either a class that overloads the function call operator() or a function pointer of the form <code>bool (__cdecl *lessThan)(const T&amp; elem1, const T&amp; elem2)</code> </p>

</div>
</div>
<a class="anchor" id="a0ced3a30c62f7dbc7115a590ab2336ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int MIN_ELEMENTS = 10, size_t MIN_BYTES = 32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3DLite_1_1Array.html">G3DLite::Array</a>&lt; T, MIN_ELEMENTS, MIN_BYTES &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3DLite_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"The member function swaps the controlled sequences between *this and str." Note that this is slower than the optimal std implementation.</p>
<p>For compatibility with std::vector. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 10 2013 14:48:43 for MinVR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
